<!DOCTYPE html>
<html>
<head>
    <title>Dynamic RAG Realtime Audio</title>
    <style>
        body { font-family: Arial; max-width: 900px; margin: 50px auto; padding: 20px; background: #f5f5f5; }
        h1 { color: #333; }
        .card { background: white; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        input, button { padding: 10px; margin: 5px; border-radius: 5px; border: 1px solid #ddd; }
        button { background: #007bff; color: white; border: none; cursor: pointer; font-weight: bold; }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .status { padding: 15px; border-radius: 5px; margin: 10px 0; font-weight: bold; }
        .connected { background: #d4edda; color: #155724; }
        .disconnected { background: #f8d7da; color: #721c24; }
        .log { background: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; }
        .log-entry { margin: 5px 0; padding: 5px; border-left: 3px solid #007bff; }
        .log-rag { border-left-color: #28a745; }
        .log-error { border-left-color: #dc3545; }
    </style>
</head>
<body>
    <h1>üéôÔ∏è Dynamic RAG Realtime Audio</h1>
    <p style="color: #666;">Voice-to-voice with real-time knowledge base searches per question</p>
    
    <div class="card">
        <h3>Configuration</h3>
        <label>Knowledge Base ID:</label>
        <input type="text" id="kbId" placeholder="Enter KB ID" style="width: 400px;">
        <br><br>
        <button onclick="connect()" id="connectBtn">üîå Connect</button>
        <button onclick="disconnect()" id="disconnectBtn" disabled>‚ùå Disconnect</button>
    </div>
    
    <div id="status" class="status disconnected">Disconnected</div>
    
    <div class="card">
        <h3>Event Log</h3>
        <div id="log" class="log"></div>
    </div>
    
    <script>
        let ws = null;
        let audioContext = null;
        let mediaStream = null;
        let nextPlayTime = 0;
        let isNewResponse = true;
        let activeSources = [];  // Track all playing sources
        
        function log(msg, type = 'info') {
            const logDiv = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            const className = type === 'rag' ? 'log-rag' : type === 'error' ? 'log-error' : '';
            logDiv.innerHTML += `<div class="log-entry ${className}">[${time}] ${msg}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(msg);
        }
        
        function playAudioChunk(base64Audio) {
            try {
                const binaryString = atob(base64Audio);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                const pcm16 = new Int16Array(bytes.buffer);
                const float32 = new Float32Array(pcm16.length);
                for (let i = 0; i < pcm16.length; i++) {
                    float32[i] = pcm16[i] / 32768.0;
                }
                
                const audioBuffer = audioContext.createBuffer(1, float32.length, 24000);
                audioBuffer.getChannelData(0).set(float32);
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                
                // Schedule playback
                const currentTime = audioContext.currentTime;
                if (isNewResponse || nextPlayTime < currentTime) {
                    nextPlayTime = currentTime;
                    isNewResponse = false;
                }
                
                source.start(nextPlayTime);
                nextPlayTime += audioBuffer.duration;
                
                // Track active source
                activeSources.push(source);
                source.onended = () => {
                    const index = activeSources.indexOf(source);
                    if (index > -1) activeSources.splice(index, 1);
                };
                
            } catch (e) {
                console.error('Audio playback error:', e);
            }
        }
        
        function stopAllAudio() {
            // Stop all currently playing audio
            activeSources.forEach(source => {
                try {
                    source.stop();
                } catch (e) {}
            });
            activeSources = [];
            nextPlayTime = 0;
            isNewResponse = true;
        }
        
        async function connect() {
            const kbId = document.getElementById('kbId').value;
            if (!kbId) {
                alert('Please enter a Knowledge Base ID');
                return;
            }
            
            try {
                log('üîå Connecting to server...');
                document.getElementById('connectBtn').disabled = true;
                
                ws = new WebSocket('ws://localhost:8003/ws');
                
                ws.onopen = async () => {
                    log('‚úÖ Connected to server');
                    
                    ws.send(JSON.stringify({ kb_id: kbId }));
                    log(`üìö Using KB: ${kbId}`);
                    
                    log('üé§ Requesting microphone...');
                    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    log('‚úÖ Microphone access granted');
                    
                    audioContext = new AudioContext({ sampleRate: 24000 });
                    const source = audioContext.createMediaStreamSource(mediaStream);
                    const processor = audioContext.createScriptProcessor(4096, 1, 1);
                    
                    processor.onaudioprocess = (e) => {
                        if (ws.readyState === WebSocket.OPEN) {
                            const inputData = e.inputBuffer.getChannelData(0);
                            const pcm16 = new Int16Array(inputData.length);
                            for (let i = 0; i < inputData.length; i++) {
                                pcm16[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32768));
                            }
                            
                            ws.send(JSON.stringify({
                                type: 'input_audio_buffer.append',
                                audio: btoa(String.fromCharCode(...new Uint8Array(pcm16.buffer)))
                            }));
                        }
                    };
                    
                    source.connect(processor);
                    processor.connect(audioContext.destination);
                    
                    document.getElementById('status').textContent = 'Connected - Speak now!';
                    document.getElementById('status').className = 'status connected';
                    document.getElementById('disconnectBtn').disabled = false;
                    
                    log('‚úÖ Ready! Start speaking...');
                    log('üí° RAG searches happen automatically per question');
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    const type = data.type;
                    
                    // Stop previous audio on new response
                    if (type === 'response.created') {
                        stopAllAudio();
                        log('üîä Stopped previous audio - new response starting');
                    }
                    
                    if (type === 'response.function_call_arguments.done') {
                        const args = JSON.parse(data.arguments || '{}');
                        log(`üîç RAG Search: "${args.query}"`, 'rag');
                    }
                    
                    if (type === 'response.audio.delta' && data.delta) {
                        playAudioChunk(data.delta);
                    }
                    
                    if (type === 'conversation.item.input_audio_transcription.completed') {
                        log(`üë§ You: ${data.transcript}`);
                    }
                    
                    if (type === 'response.audio_transcript.done') {
                        log(`ü§ñ AI: ${data.transcript}`);
                    }
                    
                    if (type === 'error') {
                        log(`‚ùå Error: ${data.error.message}`, 'error');
                    }
                };
                
                ws.onerror = (error) => {
                    log('‚ùå WebSocket error', 'error');
                    console.error(error);
                };
                
                ws.onclose = () => {
                    log('üîå Disconnected');
                    disconnect();
                };
                
            } catch (error) {
                log(`‚ùå Error: ${error.message}`, 'error');
                document.getElementById('connectBtn').disabled = false;
            }
        }
        
        function disconnect() {
            if (ws) {
                ws.close();
                ws = null;
            }
            
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            
            stopAllAudio();
            
            document.getElementById('status').textContent = 'Disconnected';
            document.getElementById('status').className = 'status disconnected';
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
            
            log('‚úÖ Disconnected successfully');
        }
    </script>
</body>
</html>
